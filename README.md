# growingnetworks
Building networks from oscillations on nodes

## Requirements 
* Python 3.8 (for compatibility with `pygraphviz`, see below). 
  * Install the python packages in requirements.txt using `python -m pip install -r requirements.txt`
  * Install Graphviz 7.0.1 (used with `networkx` package to visualize graphs)
  * Install package `pygraphviz` as described here https://pygraphviz.github.io/documentation/stable/install  
note: on Windows, the steps described there fail on Python 3.10 but work on Python 3.8 -- use this command:  
`python -m pip install --global-option="build_ext" --global-option="-IC:\Program Files\Graphviz\include" --global-option="-LC:\Program Files\Graphviz\lib" pygraphviz==1.10`
* MATLAB (only used for specific steps of the figure generation and network analysis)
  * download readNPY https://github.com/kwikteam/npy-matlab to read numpy files into MATLAB
    
## Overview of how the figures in the main text were generated

**Prerequisites:**
1) download the code and install dependencies listed in code readme.txt  
2) to use the jupyter notebooks that load the simulated data underlying Figure 4, extract the contents of the two *.7z files found in the input subdirectories:  
	`input/archive_sweeps/3D/big_100x160x181_beta0_zpulse_divPlusMinus`  
	`input/archive_sweeps/3D/small_80x200x61_beta0_zpulse_divPlusMinus`  

**Figure 3:**  
	- run the jupyter notebook found in `notebooks/visualize_cellgraph.ipynb` with parameters v, c, \delta, \beta, and t_p listed in Table S2  
	- note that the parameter are labeled as follows in the script:  
        v        -> `cellgraph.sc_template.params_ode['pulse_vel'] = 0.067`  
        c        -> `diffusion_arg = 0.300`  
        \delta -> `alpha_sharing = -0.004`   
        \beta  -> `beta_sharing = 0.0`  
        t_p     -> `cellgraph.sc_template.params_ode['t_pulse_switch'] = 75.0`
            
**Figure 4:**  
	- the plot in panel b can be regenerated by running `notebooks/plot_figures_4_and_5.ipynb`  
	- the steps to regenerate data of this type are as follows:  
		a) generate *.pkl file using `run_sweep.py` (this is the main bottleneck in general) using parameters in Table S2  
		b) generate *.npz file using `load_sweep.py` functions `digest_sweep(...)` or `wrapper_load_or_digest_sweep(...)`  
		c) from the *.npz file, generate three *.npy files containing the isomorphisms, num_cells, and unique_network_id arrays contained in the *.npz container  
		d) open MATLAB; use `addpath` to make sure that the folder with readNPY scripts are in the path list  
		e) use the *.npy files as input to run the provided MATLAB script `matlab/plot_network_cube_simplified_linear_updated.m`; this generates a file `Iso_Graph_Node_Info.csv`
		f) run the jupyter notebook found in `notebooks/plot_figures_4_and_5.ipynb`
	
**Figures 5 and S4:**   
	- run notebook `notebooks/plot_figures_4_and_5.ipynb`   
	- the underlying data (including final adjacency matrices associated to each point) can be regenerated by:  
		a) `run_sweep.py` -- first perform a "1D sweep" using the parameters from Table S2  
		b) `load_sweep.py` -- process the `sweep.pkl` file using the function `visualize_sweep_data_1D(...)`; see example code in main  
